\chapter{Processing libraries}

This milestone summarizes development results of stages \ref{num:stage2} - \ref{num:stage7} described in \Nameref{sec:developmentStages}.

\section{Reflection-based member provider}

\subsection{Reflection library}

This is the most important library of this project, as it shall provide type and member information, which will then be mapped to extracted documentation. If fully implementing this library using reflection fails, then the complexity of the project would sky rocket, as the only other viable option is parsing source code directly.

The proof of concept (see \ref{chap:proofConcept}) was built using \ref{gloss:dotnetlabel} Framework and utilized the built-in reflection capabilities. Moreover, all tests were done on non-complex assemblies without references. This was a fatal oversight. \ref{gloss:dotnetlabel} Core provides reflection capabilities; however, it does not allow loading an assembly without its references. This meant, that the researched solution was of no use, and an alternative had to be found.

Fortunately, after considerable effort, it was. The issue was solved by a third-party reflection library called \textit{dnlib} which is most notably used for obfuscating code in \ref{gloss:dotnetlabel} assemblies using its assembly modification features. For the purposes of reading and extracting required data, \textit{dnlib} was more than sufficient.

\subsection{Separation of types}

The documentation generating tool would allow selecting individual assemblies. This implies, that a user can select only a subset of assemblies generated by a project; thus, introducing the possibility of exclusion of a referenced assembly and its types.

Given that, the member resolver would produce a set types defined within the given assembly, and types referenced by their members. Once all assemblies are loaded, and the next process accesses a referenced type, it can verify whether or not the type provided via the loaded assemblies. If it is not, only the type name is preserved.

This is especially important for the Linker component, that will create links between references and documentations of said types.

\subsection{Dynamic types and value types}

Both \textit{dnlib} and the built-in \ref{gloss:dotnetlabel} reflection do not provide complete details about the extracted types and members. This implies that additional effort has to be made to extract necessary information. In some cases such effort is much more considerable than in others.

The most complex cases were for members than either returned, or accepted \lstinline[language=csh]{dynamic} types, and value tuples. A \lstinline[language=csh]{dynamic} type is a regular \lstinline[language=csh]{object} type, but with compile-time syntax checking disabled. This allows developers to access type members without casting it to its corresponding type. A value tuple is an extension of the regular C\# tuple, but with more synctactical suger that allows labling each tuple entry with a name.

\begin{lstlisting}[language=csh]
    Tuple<int, string> studentAgeClassic; // Classic tuple

    (int age, string name) studentAgeNew; // Value tuple with labels
    (int, string) studentAgeNewNameless; // Value tuple without labels
\end{lstlisting}

Reflection displays \lstinline[language=csh]{dynamic} types as \lstinline[language=csh]{object}, and hides value tuple labels. This obfuscates the special cases mentioned above.

Necessary information for deobfuscating said cases is hidden in attributes decorating the given member. Said attributes provide a flat map indicating which types are \lstinline[language=csh]{dynamic} and value tuple labels. However, this result cannot be used straight away, since returned, or accepted types by a member can be more complex. For example, the type can be tuple of objects, some of which are dynamic. Or the type could be a value tuple with one of its entries also being a value tuple. This introduces structural complexity, that cannot be mapped trivially to a flat list provided by the attributes.

The solution for this is a complex algorithm for processing the flat list from the attributes, filtering out unnecessary information, and mapping it to the provided type from the member.

\subsection{Missing features}

The developed implementation of the member resolver component covers many cases, and provides a lot of useful information about types from given assemblies. Unfortunately, not everything had been implemented, either because it was not a priority, or was unclear on how to implement.

\subsubsection{Attributes}

Attributes are annotations for types, members, or parameters, that add metadata. The tool can generate documentation for attributes, as they are just classes inheriting a special \lstinline[language=csh]{Attribute} class, but it does not link attributes to types, members, or parameters they decorate.

\subsubsection{Links to source code}

It can be beneficial to quickly access a line of code defining a given documented type or member. For example, the documentation is hosted on a Git platform, and it links to the exact lines of the source code. Nevertheless, it was not possible to create a working solution, as for unknown reasons some assemblies provided necessary information, while others did not. Thus, this feature cannot be delivered, as it is unstable.

\subsubsection{Reference to source assembly}

It can be beneficial to see from which assembly the given types was extracted from. It is trivial to implement; although, this feature had a low priority and was left out for this development cycle.

\section{XML documentation provider}

\section{Linker}

\section{Markdown elements}

\section{Composer}

\section{Printer}