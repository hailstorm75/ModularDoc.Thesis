\chapter{Proof of concept}

Creation of a proof of concept application is the ideal first step when numerous unknowns are present. Thus, investing time into this stage should reveal the potential complexity of the full project, and provide an opportunity for research, allowing further planning for the most efficient execution of development.

\textbf{Disclaimer:}
development of the proof of concept took place in November, 2018. During said time, \ref{gloss:dotnetlabel} Framework was still the dominant platform for desktop application development; thus, \ref{gloss:dotnetlabel} Core, or \ref{gloss:dotnetlabel} and following version available today, were not used in this stage (see \ref{chap:overviewNET}).

\section{Documentation extraction methodologies}
When it comes to retrieving documentation from source code, the most obvious method would be to parse said source code and extract all required data from it. Such a strategy would invole writing a custom parser, probably utilizing complex regular expressions. The problem with this method is the unpredictable nature of written code, as a programmer might incorrectly format said code, or a radical update to the code syntax might occur. This results in unknowns that would have to be handled by the source code parser.

One might say, that there is no need to write a custom parser, as Microsoft has already done that - the \ref{gloss:dotnetlabel} compiler, Roslyn, is fully capable of parsing source code. Its capabilities are exposed via \ref{itm:api}s that can be accessed by developers to create their own custom tools. This would be a great solution if not for the dependency on the Roslyn compiler. With said dependency present, it is not possible to create a standalone tool which would work on any system, regardless of whether developer tools are present or not.

Fortunately, \ref{gloss:dotnetlabel} provides reflection - the ability to examine or modify loaded assemblies during runtime. This feature allows developers to either reflect the running program and its references, or load other non-obfuscated assemblies. This method would require correclty parsing the loaded data from the assemblies; however, unlike the previous alternative, there is no dependency on the Roslyn compiler. Given these facts, it should be possible to extract type signatures from assemblies, and documentation from the \ref{itm:xml} files (see \ref{chap:netDocumentation}). Documentation extracted from the \ref{itm:xml} files would have to be mapped to the types and members extracted from the assemblies.

Thus, the proof of concept project will be used to test the possibility to extract all relevant information via reflection and \ref{itm:xml} files. If it proves to be possible, then this method would be applied in the real project. Otherwise, using Roslyn is the best alternative.

\section{Open-source project hosting platforms}
When it comes to hosting an open-source project, developers have the following cloud platforms to choose from:
\begin{itemize}
    \item GitHub
    \item GitLab
    \item Bitbucket
    \item Azure DevOps
    \item Sourceforge
\end{itemize}

There are solutions for hosting a project locally on dedicated hardware; however, this is mainly suitable for propriatary, or private projects.

As an in-depth evaluation and description of each cloud platform would reach outside the scope of this thesis, excuse the brief intrduction of said platforms:

\textbf{GitHub}: the most popular platform for open-source projects, providing tools not only for managing project, but for discovering them.

\textbf{GitLab}: a newcomer to the \ref{gloss:git} hosting space. Primarily focuses on corporate clients; however, provides powerful features for free to open-source projects.

\textbf{Bitbucket}: a platform commonly used by corporations and seldom for open-source projects

\textbf{Azure DevOps}: just like Bitbucket, but slightly more popular with the open-source community due to integration features with GitHub

\textbf{Sourceforge}: classic platform for hosting open-source projects before \ref{gloss:git} became mainstream, declining in popularity and usage

Given previous experience with GitHub and Azure DevOps, the side-goal of this stage would be to asses GitLab as a potential hosting platform by publishing the proof of concept project on it. Additionally, this is an opportunity to learn how GitLab users would potentially host the generated documentation by the custom tool.

\section{Parsing data into markdown}
// TODO: Describe markdown

\section{Development goals summary}
This development stage would focus on analysing:
\begin{itemize}
    \item whether it is possible to extract all relevant data from \ref{gloss:dotnetlabel} assemblies via reflection,
    \item whether GitLab is a viable platform for an open-source project,
    \item how to parse the extracted data into a human-readable output; how to generate Markdown.
\end{itemize}

\section{Development result}

The result of this development stage was a proof of concept console application, that
\begin{itemize}
    \item proves that reflection is sufficient,
    \item reminded the importance of Single Responsibility and Interface Segragation principles from SOLID,
    \item helped write a Markdown generator,
    \item and provided understanding of GitLab and its Wiki for hosting the tools generated output,
\end{itemize}

Given these facts, it was an undoughtably a useful investment of time and effort.