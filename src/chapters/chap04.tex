\chapter{Proof of concept}

Creation of a proof of concept application is the ideal first step when numerous unknowns are present. Thus, investing time into this stage should reveal the potential complexity of the full project, and provide an opportunity for research, allowing further planning for the most efficient execution of development.

\textbf{Disclaimer:}
development of the proof of concept took place in November, 2018. During said time, \ref{gloss:dotnetlabel} Framework was still the dominant platform for desktop application development; thus, \ref{gloss:dotnetlabel} Core, or \ref{gloss:dotnetlabel} and following version available today, were not used in this stage (see \ref{chap:overviewNET}).

\section{Milestone goals analysis}

\subsection{Documentation extraction methodologies}
When it comes to retrieving documentation from source code, the most obvious method would be to parse said source code and extract all required data from it. Such a strategy would invole writing a custom parser, probably utilizing complex regular expressions. The problem with this method is the unpredictable nature of written code, as a programmer might incorrectly format said code, or a radical update to the code syntax might occur. This results in unknowns that would have to be handled by the source code parser.

One might say, that there is no need to write a custom parser, as Microsoft has already done that - the \ref{gloss:dotnetlabel} compiler, Roslyn, is fully capable of parsing source code. Its capabilities are exposed via \ref{itm:api}s that can be accessed by developers to create their own custom tools. This would be a great solution if not for the dependency on the Roslyn compiler. With said dependency present, it is not possible to create a standalone tool which would work on any system, regardless of whether developer tools are present or not.

Fortunately, \ref{gloss:dotnetlabel} provides reflection - the ability to examine or modify loaded assemblies during runtime. This feature allows developers to either reflect the running program and its references, or load other non-obfuscated assemblies. This method would require correclty parsing the loaded data from the assemblies; however, unlike the previous alternative, there is no dependency on the Roslyn compiler. Given these facts, it should be possible to extract type signatures from assemblies, and documentation from the \ref{itm:xml} files (see \ref{chap:netDocumentation}). Documentation extracted from the \ref{itm:xml} files would have to be mapped to the types and members extracted from the assemblies.

Thus, the proof of concept project will be used to test the possibility to extract all relevant information via reflection and \ref{itm:xml} files. If it proves to be possible, then this method would be applied in the real project. Otherwise, using Roslyn is the best alternative.

\subsection{Open-source project hosting platforms}
Developers have the following cloud platforms to choose from to host their open-source projects:
\begin{itemize}
    \item GitHub
    \item GitLab
    \item Bitbucket
    \item Azure DevOps
    \item Sourceforge
\end{itemize}

There are solutions for hosting a project locally on dedicated hardware; however, this is mainly suitable for propriatary, or private projects.

As an in-depth evaluation and description of each cloud platform would reach outside the scope of this thesis, excuse the brief intrduction of said platforms:

\textbf{GitHub}: the most popular platform for open-source projects, providing tools not only for managing project, but for discovering them.

\textbf{GitLab}: a newcomer to the \ref{gloss:git} hosting space. Primarily focuses on corporate clients; however, provides powerful features for free to open-source projects.

\textbf{Bitbucket}: a platform commonly used by corporations and seldom for open-source projects

\textbf{Azure DevOps}: just like Bitbucket, but slightly more popular with the open-source community due to integration features with GitHub

\textbf{Sourceforge}: classic platform for hosting open-source projects before \ref{gloss:git} became mainstream, declining in popularity and usage

Given previous experience with GitHub and Azure DevOps, the side-goal of this stage would be to asses GitLab as a potential hosting platform by publishing the proof of concept project on it. Additionally, this is an opportunity to learn how GitLab users would potentially host the generated documentation by the custom tool.

\subsection{Parsing data into markdown}
Markdown is a simple markup language for writing formatted text. The created markup is then rendered into the desired formatted text. The rendering occurrs, for example, on Git hosting platforms.

Since the custom documentation generating tool is to output the result in Markdown, a Markdown output generator must be written. To do that, the markup language must be studied.

\subsection{Generating class inheritance diagrams}
Class inheritance diagrams would prove to be a useful part for source code documentation. Nevertheless, analysis of this topic will be omitted in this milestone, as it is not a core feature.

\subsection{Development goals summary}
This development stage would focus on analysing:
\begin{itemize}
    \item whether it is possible to extract all relevant data from \ref{gloss:dotnetlabel} assemblies via reflection,
    \item whether GitLab is a viable platform for an open-source project,
    \item how to parse the extracted data into a human-readable output; how to generate Markdown.
\end{itemize}

\section{Development results}

\subsection{Reflection for data extraction}

Using reflection is sufficient for extracting type and member data from selected assemblies. Nevertheless, this methodology requires additional effort to work correctly for the following reasons:
\begin{itemize}
    \item the compiler generates extra types and members
    \item signatures extracted via reflection of some \ref{gloss:dotnetlabel} types differ from the signatures in the source code
    \begin{itemize}
        \item the \lstinline[language=csh]{dynamic} type is compiled as \lstinline[language=csh]{object}
        \item named value tuples (e.g. \lstinline[language=csh]{(int age, string name)}) are presented without names as regular tuples (e.g. \lstinline[language=csh]{Tuple<int, string>})
    \end{itemize}
    \item generic type parameters are not directly accessible
    \item named value tuple names are not directly accessible
    \item determining the line number of a given member in its source code is unclear
\end{itemize}

\subsection{SOLID principles}

\subsection{Git platforms for hosting open-source projects}

\subsection{Git platforms for hosting Markdown documentation}

During this stage, four platforms were tested for their capabilities in hosting source code documentation in their Wiki pages: GitLab, GitHub, Bitbucket, and Azure DevOps.

Out of the four, GitLab has full support for Markdown and \ref{itm:html} tags. Its Wiki is delivered as a separate repository, enabling users to clone it and edit pages in bulk. Moreover, the Wiki can be structured into folders.

Azure DevOps is very similar to GitLab in the sense that the pages are hosted in a repository; and thus, can be cloned and edited in bulk. Again, the pages can be separated into folders. However, the page \ref{itm:url}s contain an additional numeric parameter unique to each page, the purpose of which is unknown. Because of this unknown parameter and rules for its creation, it is not possible to support linking between generated documentation pages.

GitHub, on the other hand, does not offer a way to structure the Wiki using folders, neither does it allow users to edit pages in bulk, since there is no ability to access the wiki pages as a repository. So, if the custom documentation generating tool would generate a Markdown file for each type, then the user would have to manually upload each file using GitHubs UI.

Bitbucket has the worst support for Wikis. Just like GitHub, there is no ability to edit pages in bulk. Moreover, support for Markdown is limited, as \ref{itm:html} tags are not rendered, headers do not have anchor links, and more.
Nevertheless, this is not a problem for clients using Bitbucket, as Atlassian, the company behind Bitbucket, offers Confluence - an online knowledgebase. So, support Confluence has a higher priority than Bitbucket.

\subsection{Markdown generator}

\subsection{Results summary}

The result of this development stage was a proof of concept console application, that
\begin{itemize}
    \item proves that reflection is sufficient,
    \item reminded the importance of Single Responsibility and Interface Segragation principles from SOLID,
    \item helped write a Markdown generator,
    \item and provided understanding of GitLab and its Wiki for hosting the tools generated output,
\end{itemize}

Given these facts, it was an undoughtably a useful investment of time and effort.