\chapter{Proof of concept} \label{chap:proofConcept}

Creation of a proof of concept application is the ideal first step when numerous unknowns are present. Thus, investing time into this stage should reveal the potential complexity of the full project, and provide an opportunity for research, allowing further planning for the most efficient execution of development.

\section{Milestone goals analysis}

\subsection{Documentation extraction methodologies}
When it comes to retrieving documentation from source code, the most obvious method would be to parse said source code and extract all required data from it. Such a strategy would invole writing a custom parser, probably utilizing complex regular expressions. The problem with this method is the unpredictable nature of written code, as a programmer might incorrectly format said code, the source files might not even be compilable, or a radical update to the code syntax might occur that the tool must cover. This results in unknowns that would have to be handled by the source code parser.

One might say, that there is no need to write a custom parser, as Microsoft has already done that - the \ref{gloss:dotnetlabel} compiler, Roslyn, is fully capable of parsing source code. Its capabilities are exposed via \ref{itm:api}s that can be accessed by developers to create their own custom tools. This would be a great solution if not for the dependency on the Roslyn compiler. With said dependency present, it is not possible to create a standalone tool which would work on any system, regardless of whether \ref{gloss:dotnetlabel} developer tools are present or not.

Fortunately, reflection is also an option - the ability to examine or modify loaded assemblies during runtime. This feature allows developers to either reflect the running program and its references, or load other non-obfuscated assemblies for reflection. This method would require correclty parsing the loaded data from the assemblies; however, unlike the previous alternatives, there is no dependency on the Roslyn compiler, nor is there uncertainty in the quality of the source of data. Given these facts, it should be possible to extract relevant data from assemblies, and documentation from the \ref{itm:xml} files (see \ref{chap:netDocumentation}). Both data sources will have to be mapped to each other, e.g. documentation for a given class is mapped to the parsed class signature.

Thus, the proof of concept project will be used to test the possibility to extract all relevant information via reflection and \ref{itm:xml} files. If it proves to be possible, then this method would be applied in the real project. Otherwise, using Roslyn is the best alternative.

\subsection{Open-source project hosting platforms}
Developers have the following cloud platforms to choose from to host their open-source projects:
\begin{itemize}
    \item GitHub
    \item GitLab
    \item Bitbucket
    \item Azure DevOps
    \item Sourceforge
\end{itemize}

There are solutions for hosting a project locally on dedicated hardware; however, this is mainly suitable for propriatary, or private projects.

As an in-depth evaluation and description of each cloud platform would reach outside the scope of this thesis, excuse the brief introduction of said platforms:

\textbf{GitHub}: the most popular platform for open-source projects, providing tools not only for managing project, but for discovering them.

\textbf{GitLab}: a newcomer to the \ref{gloss:git} hosting space. Primarily focuses on corporate clients; however, provides powerful features for free to open-source projects.

\textbf{Bitbucket}: a platform commonly used by corporations and seldom for open-source projects

\textbf{Azure DevOps}: just like Bitbucket, but slightly more popular with the open-source community due to integration features with GitHub

\textbf{Sourceforge}: classic platform for hosting open-source projects before \ref{gloss:git} became mainstream, declining in popularity and usage

Given previous experience with GitHub and Azure DevOps, the side-goal of this stage would be to asses GitLab as a potentially alternative hosting platform to GitHub by publishing the proof of concept project on it. Additionally, this is an opportunity to learn how GitLab users would potentially host the generated documentation by the custom tool.

\subsection{Parsing data into markdown}
Markdown is a simple markup language for writing formatted text. The created markup is then rendered into the desired formatted text. The rendering occurrs, for example, on Git hosting platforms.

Since the custom documentation generating tool is to output the result in Markdown, a Markdown output generator must be written. To do that, the markup language must be studied.

\subsection{Generating class inheritance diagrams}
Class inheritance diagrams would prove to be a useful part for source code documentation. Nevertheless, analysis of this topic will be omitted in this milestone, as it is not a core feature.

\subsection{Development goals summary}
This development stage would focus on analysing:
\begin{itemize}
    \item whether it is possible to extract all relevant data from \ref{gloss:dotnetlabel} assemblies via reflection,
    \item whether GitLab is a viable platform for an open-source project,
    \item how to parse the extracted data into a human-readable output; how to generate Markdown.
\end{itemize}

\section{Development results}

\subsection{Reflection for data extraction}

Using reflection is sufficient for extracting type and member data from selected assemblies. Nevertheless, this methodology requires additional effort to work correctly for the following reasons:
\begin{itemize}
    \item the compiler generates extra types and members
    \item signatures extracted via reflection of some \ref{gloss:dotnetlabel} types differ from the signatures in the source code
    \begin{itemize}
        \item the \lstinline[language=csh]{dynamic} type is compiled as \lstinline[language=csh]{object}
        \item named value tuples (e.g. \lstinline[language=csh]{(int age, string name)}) are presented without names as regular tuples (e.g. \lstinline[language=csh]{Tuple<int, string>})
    \end{itemize}
    \item generic type parameters are not directly accessible
    \item named value tuple names are not directly accessible
    \item determining the line number of a given member in its source code is unclear
\end{itemize}

\subsection{Design pattern importance}

One of the defined goals for this thesis is to produce an extensible application. To achieve said goal, design patterns such as SOLID, DI and pluginable architecture will be applied.
The proof of concept application was rapidly developed without intentionally applying any design patterns. This both helped to quickly develop a simple application, and showed that incorrect use or absence of design patterns will produce an unmaintainable application.

\subsection{Git platforms for hosting open-source projects}

The proof of concept project source code was hosted on GitLab to test said platforms capabilities. Other platforms were not tested in the scope of this thesis; nevertheless, said platforms were tested via other personal projects.

GitLab is a freemium platform, that offers all of its features for public open-source projects. It has a very capable CI/CD platform, along with a complete set of tools for Agile development. GitLab includes features for discovering other projects, but it clearly shows, that it is not the primary focus of the platform.

On the other hand, GitHub has the upper hand in project discoverability. In a sense, GitHub is a social platform for developers. Moreover, GitHub hosts a sizeable amount of projects, and has been on the market long enough, to be considered a mature platform. Some might view the simplicity of its tools for projects management as a downside. Nevertheless, if a project requires complex management tools, GitHub allows users to connect it to Azure DevOps, which has the complete set of tools for agile development.

\subsection{Git platforms for hosting Markdown documentation}

During this stage, four platforms were tested for their capabilities in hosting source code documentation in their Wiki pages: GitLab, GitHub, Bitbucket, and Azure DevOps.

Out of the four, GitLab has the best implementation of their Wiki. It offers full support for Markdown and \ref{itm:html} tags.
Its Wiki is delivered as a separate repository, enabling users to clone it and edit pages in bulk. Moreover, its content can be structured into folders for better documentation organization.

Azure DevOps is very similar to GitLab in the sense that the pages are hosted in a repository; and thus, can be cloned and edited in bulk. Again, the pages can be separated into folders. However, the page \ref{itm:url}s contain an additional numeric parameter unique to each page, the purpose of which is unknown. Because of this unknown parameter and rules for its creation, it is not possible to support linking between generated documentation pages.

GitHub, on the other hand, does not offer a way to structure the Wiki using folders, neither does it allow users to edit pages in bulk, since there is no ability to access the wiki pages as a repository. So, if the custom documentation generating tool would generate a Markdown file for each type, then the user would have to manually upload each file using GitHubs UI, or to upload the documentation with the source code.

Bitbucket has the worst support for Wikis.
Just like GitHub, there is no ability to edit pages in bulk.
Moreover, support for Markdown is limited, as \ref{itm:html} tags are not rendered, headers do not have anchor links, and more.
Nevertheless, this is not a problem for clients using Bitbucket, as Atlassian, the company behind Bitbucket, offers Confluence - an online knowledgebase.

\subsection{Markdown generator}

The process of creating a Markdown generator provided a deeper insight into the capabilities of the text markup language. Developing the generator was not complicated and did not reveal any issues.

\subsection{Results summary}

The result of this development stage was a proof of concept console application, that
\begin{itemize}
    \item proves that reflection is sufficient,
    \item reminded the importance of proper design pattern use
    \item helped write a Markdown generator,
    \item and provided understanding of GitLab and its Wiki for hosting the tools generated output.
\end{itemize}

Given these facts, it was undoughtably a useful investment of time and effort.